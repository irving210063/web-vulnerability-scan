import logging
from pathlib import Path
from flask import Flask, render_template, url_for
from flask import request, redirect, session, send_file
from flask_login import LoginManager, current_user
from flask_session import Session
from flask_wtf.csrf import CSRFProtect
from libgravatar import Gravatar
from werkzeug.middleware.proxy_fix import ProxyFix
from .account_app import account_app
from .auth_app import auth_app
from .db import db
from .db.models import User
from .oauth2_client import oauth2_client
from . import config
import subprocess
import os
import time
import json
import threading 
from threading import Thread
import openai
import  requests
import datetime
import shutil 
import difflib
import re


__all__ = [
    'create_app',
]

logger = logging.getLogger(__name__)
BASE_DIR = Path(__file__).resolve().parent


def create_app():
    config.read_config(str(BASE_DIR / '.env'))

    app = Flask(
        __name__,
        template_folder=str(BASE_DIR / 'templates')
    )
    app.register_blueprint(auth_app)
    app.register_blueprint(account_app)
    app.config['SECRET_KEY'] = config.SECRET_KEY
    #app.config['SSL_CERTIFICATE'] = '/etc/letsencrypt/live/web-vulnerability-scan.iottalk.tw/fullchain.pem'
    #app.config['SSL_PRIVATE_KEY'] = '/etc/letsencrypt/live/web-vulnerability-scan.iottalk.tw/privkey.pem'
    # Make WSGI use those X-Forwareded HTTP headers.
    # The following X-Forwareded HTTP headers must be by the front reverse proxy.
    #
    #     - `X-Forwarded-For`
    #     - `X-Forwarded-Proto`
    #     - `X-Forwarded-Host`
    #     - `X-Forwarded-Port`
    #
    # Ref: https://werkzeug.palletsprojects.com/en/1.0.x/middleware/proxy_fix/
    if bool(config.PROXY_USED):
        app.wsgi_app = ProxyFix(app.wsgi_app, x_for=1, x_proto=1, x_host=1, x_port=1)

    # Configure Flask-SQLAlchemy
    #
    # Ref: https://tinyurl.com/26dbers4
    app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///{}/xtalk.db'.format(str(BASE_DIR))
    # Ref: https://tinyurl.com/9umn83fe
    app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
    db.init_app(app)

    # Configure Flask-Session. We use database to store session.
    #
    # Ref: https://tinyurl.com/6sn9k699
    # Ref: https://flask-session.readthedocs.io/en/latest/
    app.config['SESSION_TYPE'] = 'sqlalchemy'
    app.config['SESSION_SQLALCHEMY'] = db
    ## upload size 
    app.config['MAX_CONTENT_LENGTH'] = 50 * 1024 * 1024

    Session(app)

    # Configure Flask-Login.
    #
    # Ref: https://flask-login.readthedocs.io/en/latest/
    login_manager = LoginManager()
    login_manager.init_app(app)
    oauth2_client.init_app(app)

    # Register OAuth2 Provider information
    #
    # Ref: https://tinyurl.com/j6cnk22s
    oauth2_client.register(
        name='iottalk',
        client_id=config.OAUTH2_CLIENT_ID,
        client_secret=config.OAUTH2_CLIENT_SECRET,
        server_metadata_url=config.OIDC_DISCOVERY_ENDPOINT,
        client_kwargs={'scope': 'openid', }
    )

    # Initialize CSRFProtect app
    #
    # Ref: https://flask-wtf.readthedocs.io/en/stable/csrf.html
    CSRFProtect(app)

    with app.app_context():
        db.create_all()

    # Register custom context processor
    # Ref: https://flask.palletsprojects.com/en/1.1.x/templating/#context-processors
    @app.context_processor
    def custom_context_processor():
        def gravatar_url(email: str, **kwargs):
            return Gravatar(email).get_image(**kwargs)

        return {'gravatar_url': gravatar_url, }

    @login_manager.user_loader
    def load_user(user_id):
        return User.query.filter_by(id=user_id).first()

    #@app.before_first_request
    #def init_database():
        #b.create_all()

    @app.route('/')
    
    def index():
        if not current_user.is_authenticated:
            redirect_uri = url_for('auth.oauth2_redirect_endpoint', _external=True)
            return oauth2_client.iottalk.authorize_redirect(redirect_uri)
        return render_template('index.html')
    
    @app.route("/scan")
    
    def scan():
        return render_template("home3.html")
    
    @app.route("/runzap",methods=["POST","GET"])
    
    def runzap():
        now = datetime.datetime.now()
        time_str = now.strftime("%Y-%m-%d %H:%M:%S")
        time_str = time_str.replace("-","_").replace(" ","_").replace(":","_")
        address = request.form["address"]
        session["address"] = address
        maxdepth = request.form["maxdepth"]
        maxduration = request.form["maxduration"]   

        if request.form["authentication"] == "yes":
            is_credential = "Yes"
            loginpage = request.form["loginpage"]
            loginusername = request.form["loginusername"] 
            loginpassword = request.form["loginpassword"]
        else:
            is_credential = "No"
            loginpage = "None"
            loginusername = "None"
            loginpassword = "None"  
        name_list = []
        com_method = ""
        if address.startswith("https://"):
            name = address.lstrip("https://")
            name = name.replace(".","_").replace("/","_")
            for i in name.split("_"):
                name_list.append(i)
            com_method = "https"
        elif address.startswith("http://"):
            name = address.lstrip("http://")
            name = name.replace(".","_").replace("/","_")
            for i in name.split("_"):
                name_list.append(i)
            com_method = "http"
        # start to store upload files 
        def delete_folder(deleted_folder):
            shutil.rmtree(deleted_folder)
        store_folder =  "/home/jerry/zap/uploaded/" + name  
        uploaded_files = request.files.getlist('folder')
        os.makedirs(store_folder, exist_ok=True)   
        for ifile in uploaded_files: 
            if ifile.filename.endswith(".html") or ifile.filename.endswith(".js"):
                #print(ifile.filename)
                content = ifile.read().decode('utf-8')  # Read the file content as text
                upfile = ifile.filename.replace("/","_")
                upfile = store_folder+"/"+upfile
                with open(upfile,"w") as f:
                    f.write(content)   
        session["dirname"] = name
        ### In order to release storage , delete the opload folder and its contents in 1 hour
        threading.Timer(3600, delete_folder, args=[store_folder]).start() 
        # end of storing files
        file_name = ""
        for i in name_list:
            file_name = file_name+"_"+str(i)
        file_name = file_name.lstrip("_")
        webpage = com_method+"_"+file_name
        file_name = file_name + str("_") + str(time_str)
        scantype = request.form["scantype"]
        if scantype == "active":
            policy = request.form["category"]
            print(policy)
  
    
        # Run the subprocess in a separate thread
            def run_zap():
                subprocess.run(['python3','zap3.py',address,policy,file_name,maxdepth,maxduration,is_credential,loginpage,loginusername,loginpassword])
            t = Thread(target=run_zap)
            t.start()

            session["file_name"] = file_name
            time.sleep(10)
            return redirect("/wait?webpage={}".format(webpage))
        else:
            def run_passive():
                subprocess.run(["python3","zap_passive2.py",address,file_name,maxdepth,maxduration,is_credential,loginpage,loginusername,loginpassword])
            t = Thread(target=run_passive)
            t.start()
            session["file_name"] = file_name
            return redirect("/wait_passive?webpage={}".format(webpage))
    @app.route("/wait",methods=["POST","GET"])
    
    def wait():
        webpage = request.args.get("webpage")
        #file_name = ""
        # if webpage.startswith("https_"):
        #     file_name = webpage.lstrip("https_")
        # elif webpage.startswith("http_"):
        #     file_name = webpage.lstrip("http_")
        apikey = "plv7ln2583k25eg32fgub3bdp5"
        view_headers = {"Content-Type":"application/json"}
        #slashcount = session.pop("slashcount",None)
        domain = session.pop("address",None)
        spider_url = f'http://localhost:8080/JSON/spider/view/status/?apikey={apikey}'
        while True:
            spider_response = requests.get(spider_url)
            spider_status = spider_response.json()["status"]
            if int(spider_status) != 100:
                return render_template("spider_wait.html",spider_status = spider_status)
            else:
                break
        time.sleep(2)

        view_url = f'http://localhost:8080/JSON/ascan/view/status/?baseurl={domain}&apikey={apikey}'
        status = 0
        while status != 100:
            view_response = requests.get(view_url,headers=view_headers)
            status = int(view_response.json()["status"])
            if status != 100:
                return render_template("wait3.html",status = status)
                continue
            else:
                break
        file_name = session.pop("file_name",None)
        return redirect("/present?file_name={}".format(file_name)) 

    @app.route("/wait_passive",methods=["POST","GET"])

    def wait_passive():
        webpage = request.args.get("webpage")
        apikey = "plv7ln2583k25eg32fgub3bdp5"
        time.sleep(3)
        getinfo_url = f'http://localhost:8080/JSON/spider/view/status/?apikey={apikey}'
        while True:
            info_response = requests.get(getinfo_url)
            status = info_response.json()["status"]
            if int(status) != 100:
                time.sleep(1)
                return render_template("wait3.html",status=status)
                continue
            else:
                break
        file_name = session.pop("file_name",None)
        #file_path = "/home/jerry/zap/passive/"+str(file_name)+".txt"
        time.sleep(10)
        return redirect("/passive_present?file_name={}".format(file_name))

    @app.route("/passive_present",methods = ["POST","GET"])
    def passive_present():
        file_name = request.args.get("file_name")
        file_path = "/home/jerry/zap/passive/"+str(file_name)+".txt"
        result_list = []
        with open(file_path) as f :
            result_list = json.load(f)
        risk_order = {"High": 3, "Medium": 2, "Low": 1, "Informational": 0}
        result_list = sorted(result_list, key=lambda x: risk_order[x["risk"]], reverse=True)
        result_dic = {}
        count = -1
        for dic in result_list:
            row_dic = {}
            row_dic["risk"] = dic["risk"]
            row_dic["url"] = dic["url"].rstrip("/")
            row_dic["pluginId"] = dic["pluginId"]
            row_dic["alert"] = dic["alert"]
            row_dic["description"] = dic["description"]
            row_dic["solution"] = dic["solution"]
            row_dic["messageId"] = dic["messageId"]
            if row_dic not in result_dic.values():
                count += 1
                result_dic[count] = row_dic
        
        return render_template("result3.html",data=result_dic)

    app.route("/present",methods = ["POST","GET"])
    
    def present():
        file_name = request.args.get("file_name")
        apikey = "plv7ln2583k25eg32fgub3bdp5"
        file_path= "/home/jerry/zap/file/"+str(file_name)+".txt"
        while True:
            if os.path.exists(file_path):
                time.sleep(3)
                break
            else:
                getinfo_url = f'http://localhost:8080/JSON/spider/view/status/?apikey={apikey}'
                info_response = requests.get(getinfo_url)
                status = info_response.json()["status"]
                return render_template("wait3.html",status = status)
                time.sleep(1)
                continue
        result_list = []
        with open(file_path) as f :
            result_list = json.load(f)
        risk_order = {"High": 3, "Medium": 2, "Low": 1, "Informational": 0}
        result_list = sorted(result_list, key=lambda x: risk_order[x["risk"]], reverse=True)
        result_dic = {}
        count = -1
        for dic in result_list:
            row_dic = {}
            row_dic["risk"] = dic["risk"]
            row_dic["url"] = dic["url"]
            row_dic["pluginId"] = dic["pluginId"]
            row_dic["alert"] = dic["alert"]
            row_dic["description"] = dic["description"]
            row_dic["solution"] = dic["solution"]
            row_dic["messageId"] = dic["messageId"]
            if row_dic not in result_dic.values():
                count += 1
                result_dic[count] = row_dic

        return render_template("result3.html",data=result_dic)

    @app.route("/revised_response", methods = ["GET","POST"])
    
    def revised_response():
        messageId = request.args.get("messageId")
        alert = request.args.get("alert")
        apikey = "plv7ln2583k25eg32fgub3bdp5"
        response_url = f'http://localhost:8080/JSON/core/view/message?apikey={apikey}&id={messageId}'
        message_response = requests.get(response_url)
        #print(response)
        
        responseBody = message_response.json()["message"]["responseBody"]
        print("-----------responseBody--------------")
        #print(responseBody)
        ## two content's similarity function


        dirname = session.pop("dirname",None)
        session["dirname"] = dirname
        folder_path = "/home/jerry/zap/uploaded/" + dirname
        file_list = os.listdir(folder_path)
        ## find similarity file ##
        file_dic = {}
        sim_score = {}
        for file_name in file_list:
            file_path = os.path.join(folder_path, file_name)  # Full path to the file
            with open(file_path, 'r') as f:
            # Perform operations on the file
                content = f.read()
                file_dic[file_name] = content
                sim_score[file_name] = difflib.SequenceMatcher(None, content, responseBody).ratio()
        max_key = max(sim_score, key=lambda k: sim_score[k])
        
        score = 100 * round(sim_score[max_key],2)
        mostsimcontent = file_dic[max_key]
        print("-------------mostsimcontent------------")
        print(max_key)
        #print(mostsimcontent)
        for c in sim_score.keys():
            print(c,str(sim_score[c]))
        realfile = max_key
        
        # this is kobe's api-key
        #openai.api_key = "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"
        # this is WVS api-key
        openai.api_key = "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"
        message = "how to solve " + alert + "with below HTML code" + "\n" + mostsimcontent + "\n\n" + "please give me the whole revised code based on above HTML code and if its app.py is also to be fixed , please fix them  to  solve the " + alert + "question"+"\n"+ "please provide the revised HTML code first and revised app.py after  revised HTML code"
        #print(prompt)
        answerresponse = openai.ChatCompletion.create(
            model = "gpt-3.5-turbo-16k",    # select model
            messages =[
                {"role":"system","content":"You are now a IT Security Manager"},
                {"role":"user","content":message}
            ],
            #max_tokens = 3000,               # response tokens
            temperature = 1,                # diversity related
            top_p = 1,                   # diversity related
            n = 1,                          # num of response
        )
        progress = "Not yet"
        while progress != "stop":
            progress = answerresponse["choices"][0]["finish_reason"]
            if progress != "stop":
                continue
            else:
                time.sleep(1)
                answer = answerresponse["choices"][0]["message"]["content"]
        print("--------answer type--------")
        print(type(answer))
        print("------raw anser-----")
        print(answer)
        session["answer"] = answer
        session["realfile"] = realfile
        start_tag_list = ["<!DOCTYPE html>","<html>"]
        end_tag = "</html>"
        for tag in start_tag_list:
            start_index = answer.find(tag)
            if start_index != -1:
                break

        end_index = answer.find(end_tag) + len(end_tag)

        # Split the answer
        before_answer = answer[:start_index]
        true_answer = answer[start_index:end_index]
        after_answer = answer[end_index:]
        return render_template("revised_response2.html",before_answer=before_answer,true_answer=true_answer,after_answer= after_answer,score = score,mostsimcontent = mostsimcontent,realfile = realfile)

    @app.route("/description", methods=["GET","POST"])
    
    def description():
        description = request.args.get("des")
        alert = request.args.get("alert")
        # this is kobe's API-key
        
        openai.api_key = "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"
        message = "give me steps to slove "+alert+" and some code examples"
        answerresponse = openai.ChatCompletion.create(
            model = "gpt-3.5-turbo",    # select model
            messages =[
                {"role":"system","content":"You are now a IT Security Manager"},
                {"role":"user","content":message}
            ],
            max_tokens = 3500,               # response tokens
            temperature = 1,                # diversity related
            top_p = 1,                   # diversity related
            n = 1,                          # num of response
        )
        progress = "Not yet"
        while progress != "stop":
            progress = answerresponse["choices"][0]["finish_reason"]
            if progress != "stop":
                continue
            else:
                time.sleep(1)
                answer = answerresponse["choices"][0]["message"]["content"]
        answer = answer.lstrip("\n").lstrip("\n")
        answer_list = []

        for i in answer.split("\n\n"):
            answer_list.append(i)
        return render_template("description.html",description=description,answer_list=answer_list)
    @app.route("/response",methods = ["GET","POST"])
    def response():
        messageId = request.args.get("messageId")
        apikey = "plv7ln2583k25eg32fgub3bdp5"
        response_url = f'http://localhost:8080/JSON/core/view/message?apikey={apikey}&id={messageId}'
        message_response = requests.get(response_url)
        #print(response)
        responseBody = message_response.json()["message"]["responseBody"]
        #print(responseBody)
        return render_template("view_response.html",responseBody = responseBody)

    @app.route("/download",methods = ["GET","POST"])
    
    def download():
        def extract_html_content(string):
            if answer.find["<!DOCTYPE html>"] != -1:
                pattern = r"(<!DOCTYPE html>.*?</html>)"
            else: 
                pattern = r"(<html>.*?</html>)"
            match = re.search(pattern, string, re.DOTALL)
            if match:
                return match.group(1)
            else:
                return None

        download_folder = "/home/jerry/zap/download/"
        answer = session.pop("answer",None)
        session["answer"] = answer
        realfile = session.pop("realfile",None)
        session["realfile"] = realfile
        file_name = download_folder + "Revised_"+realfile
        with open(file_name,"w") as f:
            f.write(extract_html_content(answer))
        return send_file(file_name, as_attachment=True)
    
    return app
